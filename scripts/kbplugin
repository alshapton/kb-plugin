#!Python
# -*- encoding: utf-8 -*-
# kb v0.1.5
# A knowledge base organizer
# Copyright © 2020, gnc.
# See /LICENSE for licensing information.

"""
plugin connecting module

:Copyright: © 2021, alshapton.
:License: GPLv3 (see /LICENSE).
"""

import argparse
import sys
from typing import Dict, Sequence
from questionary import Validator, ValidationError


class pluginNameValidator(Validator):
    def validate(self,plugin_name):
        import re
        if (len(plugin_name.text) <= 10 and len(plugin_name.text) >= 4):
            pass
        else:
           raise ValidationError(
                message="Please enter a plugin name between 4 and 10 characters/digits",
                cursor_position=len(plugin_name.text),
            )  
        regex = re.compile(r"^[a-z0-9]*$")
        if re.match(regex,plugin_name.text):
            pass
        else:
            raise ValidationError(
                message="Please enter a plugin name containing lowercase letters and digits",
                cursor_position=len(plugin_name.text),
            )            


class semverValidator(Validator):
    def validate(self, version):
        import re
        if len(version.text) == 0:
            raise ValidationError(
                message="Please enter an valid semver-compliant version string",
                cursor_position=len(version.text),
            )        
        else:
            regex = re.compile(r"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$")
            if (re.match(regex, version.text)):
                pass
            else:
                raise ValidationError(
                    message="Please enter an valid semver-compliant version string",
                    cursor_position=len(version.text),
                )


class emailValidator(Validator):    
    def validate(self, email):
        import re
        if len(email.text) == 0:
            raise ValidationError(
                message="Please enter an email address",
                cursor_position=len(email.text),
            )        
        else:
            regex = re.compile(r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
            if (re.match(regex, email.text)):
                pass
            else:
                raise ValidationError(
                    message="Please enter a valid email address format",
                    cursor_position=len(email.text),
                )


class urlValidator(Validator):
    def validate(self,repo):
        import re
        if len(repo.text) == 0:
            raise ValidationError(
                message="Please enter an url",
                cursor_position=len(repo.text),
            )
        else:  
            regex = re.compile(
            r'^(?:http|ftp)s?://'                                                                   # http:// or https://
            r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'    # domain...
            r'localhost|'                                                                           # localhost...
            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|'                                                  # ...or ipv4
            r'\[?[A-F0-9]*:[A-F0-9:]+\]?)'                                                          # ...or ipv6
            r'(?::\d+)?'                                                                            # optional port
            r'(?:/?|[/?]\S+)$', re.IGNORECASE)
        if re.match(regex, repo.text):
            pass
        else:   
            raise ValidationError(
                message="Please enter a valid url format",
                cursor_position=len(repo.text),
            )


def clear():
    from subprocess import call
    from sys import platform

    if platform not in ('win32', 'cygwin'):
        command = 'clear'
    else:
        command = 'cls'
    call(command)
    return None


def construct_toml_file():
    from pathlib import Path
    return str(__file__ + '.toml')


def write_toml_file(data: str, path: str, mode: str):
    """
    Write the config to the kbplugin.toml file.
    Argument:
    data    -   the data to write to the file.
    """
    import toml
    # Write information to the .toml file.
    with open(path, mode) as tcf:
        tcf.write(toml.dumps(data))
    return True


def read_toml_file():
    import toml
    data = toml.load(construct_toml_file())
    return (data)


def write_file(data: str,path: str, mode: str):
    """
    Write data to a file.
    Argument:
    data    -   the data to write to a file.
    """
    f = open(path, mode)
    f.write(data)
    f.close()
    return True


def iskbinstalled():
    try:
        import kb.main
        return kb.main.__file__
    except ModuleNotFoundError:
        return ''


def getnow():
    from datetime import datetime
    return str(datetime.now())


def inject_connect_code(p: str):
    from pathlib import Path
    from lineinfile import ALWAYS, AfterFirst, add_line_to_file
    import os

    s = os.linesep
    now = getnow()

    line = "    # KB-PLUGIN-CONN                                              #  (KPC)" + s
    line = line + "    # Start of kb-plugin connection code                          #  (KPC)" + s
    line = line + "    # Connected at : " + now + "                   #  (KPC)" + s
    line = line + "    # DO NOT MODIFY THIS CONNECTION CODE                          #  (KPC)" + s
    line = line + "    try:                                                          #  (KPC)" + s
    line = line + "        from kb.plugin import loadModules                         #  (KPC)" + s
    line = line + "        loadModules('commands','','',COMMANDS,DEFAULT_CONFIG,cmd) #  (KPC)" + s
    line = line + "    except ModuleNotFoundError:                                   #  (KPC)" + s
    line = line + "        pass                                                      #  (KPC)" + s
    line = line + "    # End of kb-plugin connection code                            #  (KPC)" + s
    line = line + "    # KB-PLUGIN-CONN                                              #  (KPC)" + s

    add_line_to_file(
        p,
        line,
        inserter=AfterFirst(r"cmd_params = vars"),
        backup=ALWAYS,
        backup_ext=".original",
        )


def outject_connect_code(p: str):
    from pathlib import Path
    from lineinfile import ALWAYS, remove_lines_from_file

    remove_lines_from_file(
        p,
        regexp=r"\b(KPC)\b",
    )


def skeleton(args: Dict[str, str]):
    from questionary import prompt
    import os
    from pathlib import Path
    import uuid

    target_toml_file = str(Path(os.path.dirname(__file__),'config.tmp.toml'))
    os.chdir(Path.home())
    clear()
    print('Create the skeleton for a new plugin')
    print()
    print("Enter the following:")
    questions = [
                { 'type': 'text', 'name': 'author', 'message': 'Your Name: ', 'qmark': '-',
                  #'validate': lambda text: True if len(text) > 0 else "Your name"
                },
                { 'type': 'text', 'name': 'version', 'message': 'Version Number: ',
                  'instruction': 'MUST be in semver notation i.e. 0.0.1', 'qmark': '-', 
                  #'validate': semverValidator
                },
                { 'type': 'text', 'name': 'contact', 'message': 'Your Email: ', 'qmark': '-',
                #  'validate': emailValidator
                },  
                { 'type': 'text',  'name': 'plugin_name', 'message': 'The name of the new plugin: ', 'qmark': '-',
                # 'validate': pluginNameValidator
                },
                { 'type': 'text', 'name': 'help', 'message': 'Description of the plugin: ',
                  'instruction': 'Text that will appear in the help for this plugin', 'qmark': '-',
                #  'validate': lambda text: True if len(text) > 20 else "Please enter more than 20 characters"
                },
                { 
                  'type': 'text', 'name': 'detail', 'message': 'Further detail for help : ', 'qmark': '-', 
                },
                { 'type': 'path', 'name': 'location', 'message': 'Location of the plugin code (Press <TAB>): ',
                    'qmark': '-', 'only_directories': True,
                #    'validate': lambda a: True if a[1] != '.' else "You should select a directory which is not hidden"
                },
                { 'type': 'text', 'name': 'source', 'message': 'Remote repo. location: ', 
                  'qmark': '-', 
                  #'validate': urlValidator
                },
    ]

    config = prompt(questions)
    write_file('', target_toml_file, 'w')

    now = getnow()
    if iskbinstalled():
        from kb import __version__ as kb_version
    else:
        kb_version = '?.?.?'
    
    title = '# -*- encoding: utf-8 -*-\n'
    title = title + '# kb v' + kb_version + '\n'
    title = title + '# A knowledge base organizer\n'
    title = title + '# Copyright © 2020, gnc.\n'
    title = title + '# See /LICENSE for licensing information.\n\n'

    title = title + '#\n'
    title = title + '# Plugin extension plugin configuration file.\n'
    title = title + '#\n'
    title = title + '# :Copyright: © ' + now[0:4] + ', ' + config['plugin_name'] + '\n'
    title = title + '# :License: GPLv3 (see /LICENSE).\n'
    title = title + '#\n\n'
    title = title + 'title = "Config file for ' + config['plugin_name'] + ' generated by kbplugin on ' + now[0:19] + '"'

    write_file(title + '\n\n', target_toml_file, 'a')

    toml_config = {
                    'config':
                    {  
                    'name': config['plugin_name'],
                    'version': config['version'],
                    'guid': str(uuid.uuid4()),
                    'help': config['help'],
                     }
                }

    write_toml_file(toml_config, target_toml_file,'a')

    write_file('\n',target_toml_file, 'a')
    toml_metadata = {
                    'metadata':
                    {
                    'source': config['source'],
                    'author': config['author'],
                    'contact': config['contact'],
                     }
                }    
    write_toml_file(toml_metadata, target_toml_file, 'a')

   

    command_name = {'type': 'text', 'name': 'command', 'message': 'Enter the command: ', 'qmark': '-',}
    another_command = {'type': 'confirm', 'name': 'another', 'message': 'Another command ?','qmark': '-',}

    another_argument = {'type': 'confirm', 'name': 'another', 'message': 'Another argument ?','qmark': '-',}


    parser_config = {
                    'parser':
                    {
                    'prefix': config['plugin_name'],
                    'entry': config['plugin_name'] + '_command',
                    'help': config['help'],
                    'detail': config['detail'],
                     }
                } 

    write_file('\n',target_toml_file, 'a')
    write_toml_file(parser_config, target_toml_file, 'a')

    more_commands = {'another': True}
    while more_commands['another']:
        prsr_info = prompt(command_name)   
        command_questions = { 'type': 'text', 'name': 'help',
                              'message': 'Help for the ' + prsr_info["command"] + ' command: ', 'qmark': '-',
                            }
        prsr_help = prompt(command_questions)   
        command_function = { 'type': 'text', 'name': 'function',
                              'message': 'Function for the ' + prsr_info["command"] + ' command: ', 'qmark': '-',
                            }
        prsr_function = prompt(command_function)   

        commands_config = {
                            'command': prsr_info["command"],
                            'function': prsr_function['function'],
                            'help': prsr_help['help'],
                            }
        print(commands_config)
        write_file('\n[[commands]]\n',target_toml_file, 'a')
        write_toml_file(commands_config, target_toml_file, 'a')

        exit

        complete_args_info = []
        """
        
        # Get arguments
        more_args = {'another': True}
        while more_args['another']:
            this_arg_info = []
            arg_questions = [
                        {'type': 'text', 'name': 'argument', 'message': 'Option name(s): ', 'qmark': '-',},
                        {'type': 'select', 'name': 'action', 'message': 'Action to be taken: ', 'qmark': '-',
                            'choices': ['store', 'store_const', 'store_true', 'store_false', 'append', 'append_const',
                            'count', 'help', 'version', 'extend', 'Custom Action'],},
                        {'type': 'text', 'name': 'const', 'message': 'Constant to be stored: ', 'qmark': '   -',
                            "when": lambda x: x["action"] in ["store_const", "append_const"]},
                        {'type': 'text', 'name': 'customaction', 'message': 'Custom Action name: ', 'qmark': '   -',
                            "when": lambda x: x["action"] == "Custom Action",},
                        {'type': 'select', 'name': 'nargs', 'message': 'Number of arguments: ', 'qmark': '-',
                            'choices': ['?', '*', '+', '1', '2', '3', '4', '5', '6', '7', '8', '9', '>9'],},     
                        {'type': 'text', 'name': 'default', 'message': 'Default value: ', 'qmark': '-',},
                        {'type': 'select', 'name': 'type', 'message': 'Type: ', 'qmark': '-',
                            'choices': ['str', 'int', 'float', 'ascii', 'ord', 'open', 'User Defined'],},  
                        {'type': 'text', 'name': 'userdefinedtype', 'message': 'User Defined type: ', 'qmark': '   -',
                            "when": lambda x: x["type"] == "User Defined",}, 
                        {'type': 'text', 'name': 'choices', 'message': 'List of choices: ', 'qmark': '-',},
                        {'type': 'select', 'name': 'required', 'message': 'Required: ', 'qmark': '-',
                            'choices': ['Yes', 'No'],},  
                        {'type': 'select', 'name': 'arghelp', 'message': 'Help ? ', 'qmark': '-',
                            'choices': ['Yes', 'No'],},  
                        {'type': 'text', 'name': 'helpmessage', 'message': 'Help Message: ', 'qmark': '   -',
                            "when": lambda x: x["arghelp"] == "Yes",}, 
                        {'type': 'text', 'name': 'metavar', 'message': 'Metavar? ', 'qmark': '-',},
                        {'type': 'text', 'name': 'dest', 'message': 'Dest? ', 'qmark': '-',},   
                        ]
            this_arg_info = prompt(arg_questions)
            print(this_arg_info)
            more_args = prompt(another_argument)
            complete_args_info.append(this_arg_info)
        """
        #complete_parser_info.append(complete_args_info)

        more_commands = prompt(another_command)        




    return None


def connect(args: Dict[str, str]):
    import os
    from kb.filesystem import copy_file
    from pathlib import Path
    data = read_toml_file()
    isconnected = data['status']['connected']
    if (not isconnected):
        installation_path = iskbinstalled()
        if (installation_path != ''):
            data['status']['connected'] = True
            write_toml_file(data,construct_toml_file(), 'w')
            installation_dir = os.path.dirname(installation_path)
            here_path = os.path.dirname(__file__)
            copy_file(str(Path(here_path, 'plugin.py')), str(Path(installation_dir, 'plugin.py')))
            inject_connect_code(installation_path)
            print('Connected to kb instance')
            sys.exit(0)
        else:
            print('Cannot connect to kb - kb is not installed')
            sys.exit(1)
    else:
        print('kb-plugin is already connected to the kb instance')
        sys.exit(1)


def disconnect(args: Dict[str, str]):
    import os
    from pathlib import Path
    from kb.filesystem import remove_file

    data = read_toml_file()
    isconnected = data['status']['connected']
    if (isconnected):
        installation_path = iskbinstalled()
        if (installation_path != ''):
            data['status']['connected'] = False
            write_toml_file(data,construct_toml_file(), 'w')
            outject_connect_code(installation_path)
            p = os.path.dirname(installation_path)
            remove_file(str(Path(p, 'plugin.py')))
            print('Disconnected from kb instance')
            sys.exit(0)
        else:
            print('Cannot disconnect from kb - kb is not installed')
            sys.exit(1)
    else:
        print('kb-plugin is already disconnected from the kb instance')
        sys.exit(1)


def stat(args: Dict[str, str]):
    from kb.printer.style import ALT_BGROUND, BOLD, UND, RESET

    PREFIX = ''
    SUFFIX = ''
    UPREFIX = ''

    if iskbinstalled():
        from kb import __version__ as kb_version
        data = read_toml_file()
        isconnected = data['status']['connected']
        if args['no_color']:
            PREFIX = BOLD
            SUFFIX = RESET
            UPREFIX = BOLD + UND

        if (isconnected):
            connectedtext = 'Connected'
        else:
            connectedtext = 'Disconnected'
    else:
        connectedtext = 'Not Installed'
        kb_version = connectedtext

    kb_plugin_version = read_toml_file()['info']['version']
    line1 = UPREFIX + "kb-plugin Status Information" + SUFFIX
    line2 = PREFIX + "kb-plugin Version  : " + kb_plugin_version + SUFFIX
    line3 = PREFIX + "kb Version         : " + kb_version + SUFFIX
    line4 = PREFIX + "Status             : " + connectedtext + SUFFIX

    print(line1)
    print(line2)
    print(line3)
    print(line4)


def parse_args(args: Sequence[str]) -> argparse.Namespace:
    """
    This function parses the arguments which have been passed from the command
    line, these can be easily retrieved for example by using "sys.argv[1:]".
    It returns an argparse Namespace object.

    Arguments:
    args -- the list of arguments passed from the command line as the sys.argv
            format

    Returns:
    An argparse Namespace object with the provided arguments, which
    can be used in a simpler format.
    """

    parser = argparse.ArgumentParser(prog='kbplugin',
                                     description='A plugin manager for kb')
    parser.add_argument(
        "--version",
        action="version",
        version="%(prog)s {}".format(read_toml_file()['info']['version']))

    # Main Commands

    subparsers = parser.add_subparsers(help='commands', dest="command")
    subparsers.required = True

    _connect_parser = subparsers.add_parser(
        'connect', help='Connect kb-plugin to the kb instance')

    _disconnect_parser = subparsers.add_parser(
        'disconnect', help='Disconnect kb-plugin to the kb instance')

    _skeleton_parser = subparsers.add_parser(
        'skeleton', help='Create a skeleton plugin to modify')
    _skeleton_parser.add_argument(
        "name",
        help="Name of plugin to create",
        action='store_false',
        )

    _status_parser = subparsers.add_parser(
        'status', help='Show information about kb-plugin')
    _status_parser.add_argument(
        "-n", "--no-color",
        help="Enable no-color mode",
        action='store_false',
        dest='no_color',
        default=True)

    help_parser = subparsers.add_parser(
        'help', help='Show help of a particular command')
    help_parser.add_argument(
        'cmd',
        help='Name of command to get help for',
        nargs='?'
    )

    if len(args) == 0:
        parser.print_help(sys.stderr)
        sys.exit(1)

    parsed_args = parser.parse_args()
    if parsed_args.command == 'help':
        if not parsed_args.cmd:
            parser.print_help(sys.stderr)
        else:
            try:
                subparsers.choices[parsed_args.cmd].print_help()
            except KeyError:
                print(f'Unknown command name `{parsed_args.cmd}`')
                print(
                    f"Valid commands are: {', '.join(subparsers.choices.keys())}"
                )
        sys.exit(1)
    return parsed_args


def dispatch(function, *args, **kwargs):
    """
    Dispatch command line action to proper
    kb function
    """
    return CMDS[function](*args, **kwargs)


"""Main routine of kbplugin."""

CMDS = {
    'connect': connect,
    'disconnect': disconnect,
    'skeleton': skeleton,
    'status': stat,
}

args = parse_args(sys.argv[1:])
cmd = args.command
cmd_params = vars(args)
dispatch(cmd, cmd_params)
