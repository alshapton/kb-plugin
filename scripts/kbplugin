#!Python
# -*- encoding: utf-8 -*-
# kb v0.1.5
# A knowledge base organizer
# Copyright © 2020, gnc.
# See /LICENSE for licensing information.

"""
plugin connecting module

:Copyright: © 2021, alshapton.
:License: GPLv3 (see /LICENSE).
"""

import argparse
import sys
from typing import Dict, Sequence
from questionary import Validator, ValidationError


class pluginNameValidator(Validator):
    def validate(self, plugin_name):
        import re
        if (len(plugin_name.text) <= 10 and len(plugin_name.text) >= 4):
            pass
        else:
            raise ValidationError(
                message="Please enter a plugin name between 4 and 10 characters/digits",
                cursor_position=len(plugin_name.text),
            )
        regex = re.compile(r"^[a-z0-9]*$")
        if re.match(regex, plugin_name.text):
            pass
        else:
            raise ValidationError(
                message="Please enter a plugin name containing lowercase letters and digits",
                cursor_position=len(plugin_name.text),
            )


class semverValidator(Validator):
    def validate(self, version):
        import re
        if len(version.text) == 0:
            raise ValidationError(
                message="Please enter an valid semver-compliant version string",
                cursor_position=len(version.text),
            )
        else:
            regex = re.compile(r"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$")
            if (re.match(regex, version.text)):
                pass
            else:
                raise ValidationError(
                    message="Please enter an valid semver-compliant version string",
                    cursor_position=len(version.text),
                )


class emailValidator(Validator):
    def validate(self, email):
        import re
        if len(email.text) == 0:
            raise ValidationError(
                message="Please enter an email address",
                cursor_position=len(email.text),
            )
        else:
            regex = re.compile(r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
            if (re.match(regex, email.text)):
                pass
            else:
                raise ValidationError(
                    message="Please enter a valid email address format",
                    cursor_position=len(email.text),
                )


class urlValidator(Validator):
    def validate(self, repo):
        import re
        if len(repo.text) == 0:
            raise ValidationError(
                message="Please enter an url",
                cursor_position=len(repo.text),
            )
        else:
            regex = re.compile(
             r'^(?:http|ftp)s?://'                                                                   # http:// or https://
             r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'    # domain...
             r'localhost|'                                                                           # localhost...
             r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|'                                                  # ...or ipv4
             r'\[?[A-F0-9]*:[A-F0-9:]+\]?)'                                                          # ...or ipv6
             r'(?::\d+)?'                                                                            # optional port
             r'(?:/?|[/?]\S+)$', re.IGNORECASE)
        if re.match(regex, repo.text):
            pass
        else:
            raise ValidationError(
                message="Please enter a valid url format",
                cursor_position=len(repo.text),
            )




def construct_title():
    import os
    from scripts.utilities import iskbinstalled as iskbinstalled
    if iskbinstalled():
        from kb import __version__ as kb_version
    else:
        kb_version = '?.?.?'

    title = '# -*- encoding: utf-8 -*-' + os.linesep
    title = title + '# kb v' + kb_version  + os.linesep
    title = title + '# A knowledge base organizer'  + os.linesep
    title = title + '# Copyright © 2020, gnc.'  + os.linesep
    title = title + '# See /LICENSE for licensing information.' + os.linesep + os.linesep
    return title


def skeleton(args: Dict[str, str]):
    from questionary import prompt
    import os
    from scripts.utilities import getnow as getnow, clear as clear
    from pathlib import Path
    import uuid

    plugin_name = 'coffee'
    copyright = 'Andrew Shapton'

    base_dir = Path(os.path.dirname(__file__))
    target_py_file = str(Path(base_dir, 'plugins', plugin_name, 'plugin_main_tmp.py'))

    now = getnow()

    create_structure(base_dir, plugin_name)
    title = construct_title()
    title = title + '#' + os.linesep
    title = title + '# Main file for ' + plugin_name + ' plugin.' + os.linesep
    title = title + '#' + os.linesep
    title = title + '# :Copyright: © ' + now[0:4] + ', ' + copyright + os.linesep
    title = title + '# :License: GPLv3 (see /LICENSE).' + os.linesep
    title = title + '#' + os.linesep

    write_file(title  + os.linesep, target_py_file, 'w')
    append_file(str(Path(base_dir, 'parts', 'plugin_main.part1')), target_py_file)
    sys.exit(0)

    target_toml_file = str(Path(base_dir, 'config.tmp.toml'))
    os.chdir(Path.home())
    clear()
    print('Create the skeleton for a new plugin')
    print()
    print("Enter the following:")
    questions = [
                {'type': 'text', 'name': 'author', 'message': 'Your Name: ', 'qmark': '-',
                 # 'validate': lambda text: True if len(text) > 0 else "Your name"
                 },
                {'type': 'text', 'name': 'version', 'message': 'Version Number: ',
                 'instruction': 'MUST be in semver notation i.e. 0.0.1', 'qmark': '-',
                 # 'validate': semverValidator
                 },
                {'type': 'text', 'name': 'contact', 'message': 'Your Email: ', 'qmark': '-',
                 # 'validate': emailValidator
                 },
                {'type': 'text',  'name': 'plugin_name', 'message': 'The name of the new plugin: ', 'qmark': '-',
                 # 'validate': pluginNameValidator
                 },
                {'type': 'text', 'name': 'help', 'message': 'Description of the plugin: ',
                 'instruction': 'Text that will appear in the help for this plugin', 'qmark': '-',
                 # 'validate': lambda text: True if len(text) > 20 else "Please enter more than 20 characters"
                 },
                {'type': 'text', 'name': 'detail', 'message': 'Further detail for help : ', 'qmark': '-', },
                {'type': 'path', 'name': 'location', 'message': 'Location of the plugin code (Press <TAB>): ',
                 'qmark': '-', 'only_directories': True,
                 # 'validate': lambda a: True if a[1] != '.' else "You should select a directory which is not hidden"
                 },
                {'type': 'text', 'name': 'source', 'message': 'Remote repo. location: ',
                 'qmark': '-',
                 # 'validate': urlValidator,
                 },
    ]

    config = prompt(questions)
    write_file('', target_toml_file, 'w')

    now = getnow()

    title = construct_title()
    title = title + '#' + os.linesep
    title = title + '# Plugin extension plugin configuration file.' + os.linesep
    title = title + '#' + os.linesep
    title = title + '# :Copyright: © ' + now[0:4] + ', ' + config['plugin_name']  + os.linesep
    title = title + '# :License: GPLv3 (see /LICENSE).' + os.linesep
    title = title + '#' + os.linesep + os.linesep
    title = title + 'title = "Config file for ' + config['plugin_name'] + ' generated by kbplugin on ' + now[0:19] + '"'

    write_file(title  + os.linesep + os.linesep, target_toml_file, 'a')

    toml_config = {
                    'config':
                    {
                     'name': config['plugin_name'],
                     'version': config['version'],
                     'guid': str(uuid.uuid4()),
                     'help': config['help'],
                     }
                }

    write_toml_file(toml_config, target_toml_file, 'a')

    write_file( + os.linesep, target_toml_file, 'a')
    toml_metadata = {
                    'metadata':
                    {
                     'source': config['source'],
                     'author': config['author'],
                     'contact': config['contact'],
                     }
                }
    write_toml_file(toml_metadata, target_toml_file, 'a')

    command_name = {'type': 'text', 'name': 'command', 'message': 'Enter the command: ', 'qmark': '-', }
    another_command = {'type': 'confirm', 'name': 'another', 'message': 'Another command ?', 'qmark': '-', }
    another_argument = {'type': 'confirm', 'name': 'another', 'message': 'Another argument ?', 'qmark': '-', }

    parser_config = {
                    'parser':
                    {
                     'prefix': config['plugin_name'],
                     'entry': config['plugin_name'] + '_command',
                     'help': config['help'],
                     'detail': config['detail'],
                     }
                }

    write_file(os.linesep, target_toml_file, 'a')
    write_toml_file(parser_config, target_toml_file, 'a')

    more_commands = {'another': True}
    while more_commands['another']:
        prsr_info = prompt(command_name)

        command_questions = {'type': 'text', 'name': 'help',
                             'message': 'Help for the ' + prsr_info["command"] + ' command: ', 'qmark': '-', }
        prsr_help = prompt(command_questions)

        command_function = {'type': 'text', 'name': 'function',
                            'message': 'Function for the ' + prsr_info["command"] + ' command: ', 'qmark': '-', }
        prsr_function = prompt(command_function)

        commands_config = {
                            'command': prsr_info["command"],
                            'function': prsr_function['function'],
                            'help': prsr_help['help'],
                            }
        print(commands_config)
        write_file(os.linesep + '[[commands]]' + os.linesep, target_toml_file, 'a')
        write_toml_file(commands_config, target_toml_file, 'a')


        complete_args_info = []
        """

        # Get arguments
        more_args = {'another': True}
        while more_args['another']:
            this_arg_info = []
            arg_questions = [
                        {'type': 'text', 'name': 'argument', 'message': 'Option name(s): ', 'qmark': '-',},
                        {'type': 'select', 'name': 'action', 'message': 'Action to be taken: ', 'qmark': '-',
                            'choices': ['store', 'store_const', 'store_true', 'store_false', 'append', 'append_const',
                            'count', 'help', 'version', 'extend', 'Custom Action'],},
                        {'type': 'text', 'name': 'const', 'message': 'Constant to be stored: ', 'qmark': '   -',
                            "when": lambda x: x["action"] in ["store_const", "append_const"]},
                        {'type': 'text', 'name': 'customaction', 'message': 'Custom Action name: ', 'qmark': '   -',
                            "when": lambda x: x["action"] == "Custom Action",},
                        {'type': 'select', 'name': 'nargs', 'message': 'Number of arguments: ', 'qmark': '-',
                            'choices': ['?', '*', '+', '1', '2', '3', '4', '5', '6', '7', '8', '9', '>9'],},
                        {'type': 'text', 'name': 'default', 'message': 'Default value: ', 'qmark': '-',},
                        {'type': 'select', 'name': 'type', 'message': 'Type: ', 'qmark': '-',
                            'choices': ['str', 'int', 'float', 'ascii', 'ord', 'open', 'User Defined'],},
                        {'type': 'text', 'name': 'userdefinedtype', 'message': 'User Defined type: ', 'qmark': '   -',
                            "when": lambda x: x["type"] == "User Defined",},
                        {'type': 'text', 'name': 'choices', 'message': 'List of choices: ', 'qmark': '-',},
                        {'type': 'select', 'name': 'required', 'message': 'Required: ', 'qmark': '-',
                            'choices': ['Yes', 'No'],},
                        {'type': 'select', 'name': 'arghelp', 'message': 'Help ? ', 'qmark': '-',
                            'choices': ['Yes', 'No'],},
                        {'type': 'text', 'name': 'helpmessage', 'message': 'Help Message: ', 'qmark': '   -',
                            "when": lambda x: x["arghelp"] == "Yes",},
                        {'type': 'text', 'name': 'metavar', 'message': 'Metavar? ', 'qmark': '-',},
                        {'type': 'text', 'name': 'dest', 'message': 'Dest? ', 'qmark': '-',},
                        ]
            this_arg_info = prompt(arg_questions)
            print(this_arg_info)
            more_args = prompt(another_argument)
            complete_args_info.append(this_arg_info)
        """
        # complete_parser_info.append(complete_args_info)

        more_commands = prompt(another_command)

    return None



def stat(args: Dict[str, str]):
    from kb.printer.style import ALT_BGROUND, BOLD, UND, RESET
    from scripts.utilities import iskbinstalled as iskbinstalled
    from scripts.files import read_toml_file as read_toml_file
    PREFIX = ''
    SUFFIX = ''
    UPREFIX = ''

    if iskbinstalled():
        from kb import __version__ as kb_version
        data = read_toml_file(__file__)
        isconnected = data['status']['connected']
        if args['no_color']:
            PREFIX = BOLD
            SUFFIX = RESET
            UPREFIX = BOLD + UND

        if (isconnected):
            connectedtext = 'Connected'
        else:
            connectedtext = 'Disconnected'
    else:
        connectedtext = 'Not Installed'
        kb_version = connectedtext

    kb_plugin_version = read_toml_file(__file__)['info']['version']
    line1 = UPREFIX + "kb-plugin Status Information" + SUFFIX
    line2 = PREFIX + "kb-plugin Version  : " + kb_plugin_version + SUFFIX
    line3 = PREFIX + "kb Version         : " + kb_version + SUFFIX
    line4 = PREFIX + "Status             : " + connectedtext + SUFFIX

    print(line1)
    print(line2)
    print(line3)
    print(line4)

def disconnect(args: Dict[str, str]):
    from scripts.integration import disconnect as disconnect_from_kb
    disconnect_from_kb(args, __file__)
    return None


def connect(args: Dict[str, str]):
    from scripts.integration import connect as connect_to_kb
    connect_to_kb(args,__file__)
    return None

def parse_args(args: Sequence[str]) -> argparse.Namespace:
    """
    This function parses the arguments which have been passed from the command
    line, these can be easily retrieved for example by using "sys.argv[1:]".
    It returns an argparse Namespace object.

    Arguments:
    args -- the list of arguments passed from the command line as the sys.argv
            format

    Returns:
    An argparse Namespace object with the provided arguments, which
    can be used in a simpler format.
    """
    from scripts.files import read_toml_file as read_toml_file

    parser = argparse.ArgumentParser(prog='kbplugin',
                                     description='A plugin manager for kb')
    parser.add_argument(
        "--version",
        action="version",
        version="%(prog)s {}".format(read_toml_file(__file__)['info']['version']))

    # Main Commands

    subparsers = parser.add_subparsers(help='commands', dest="command")
    subparsers.required = True

    _connect_parser = subparsers.add_parser(
        'connect', help='Connect kb-plugin to the kb instance')

    _disconnect_parser = subparsers.add_parser(
        'disconnect', help='Disconnect kb-plugin to the kb instance')

    _skeleton_parser = subparsers.add_parser(
        'skeleton', help='Create a skeleton plugin to modify')
    _skeleton_parser.add_argument(
        "name",
        help="Name of plugin to create",
        action='store_false',
        )

    _status_parser = subparsers.add_parser(
        'status', help='Show information about kb-plugin')
    _status_parser.add_argument(
        "-n", "--no-color",
        help="Enable no-color mode",
        action='store_false',
        dest='no_color',
        default=True)

    help_parser = subparsers.add_parser(
        'help', help='Show help of a particular command')
    help_parser.add_argument(
        'cmd',
        help='Name of command to get help for',
        nargs='?'
    )

    if len(args) == 0:
        parser.print_help(sys.stderr)
        sys.exit(1)

    parsed_args = parser.parse_args()
    if parsed_args.command == 'help':
        if not parsed_args.cmd:
            parser.print_help(sys.stderr)
        else:
            try:
                subparsers.choices[parsed_args.cmd].print_help()
            except KeyError:
                print(f'Unknown command name `{parsed_args.cmd}`')
                print(
                    f"Valid commands are: {', '.join(subparsers.choices.keys())}"
                )
        sys.exit(1)
    return parsed_args


def dispatch(function, *args, **kwargs):
    """
    Dispatch command line action to proper
    kb function
    """
    return CMDS[function](*args, **kwargs)


"""Main routine of kbplugin."""

CMDS = {
    'connect': connect,
    'disconnect': disconnect,
    'skeleton': skeleton,
    'status': stat,
}

args = parse_args(sys.argv[1:])
cmd = args.command
cmd_params = vars(args)
dispatch(cmd, cmd_params)
