#!Python
# -*- encoding: utf-8 -*-
# kb v0.1.5
# A knowledge base organizer
# Copyright © 2020, gnc.
# See /LICENSE for licensing information.

"""
plugin connecting module

:Copyright: © 2021, alshapton.
:License: GPLv3 (see /LICENSE).
"""

import argparse
import sys
from typing import Dict, Sequence
from questionary import Validator, ValidationError


class pluginNameValidator(Validator):
    def validate(self, plugin_name):
        import re
        if (len(plugin_name.text) <= 10 and len(plugin_name.text) >= 4):
            pass
        else:
            raise ValidationError(
                message="Please enter a plugin name between 4 and 10 characters/digits",
                cursor_position=len(plugin_name.text),
            )
        regex = re.compile(r"^[a-z0-9]*$")
        if re.match(regex, plugin_name.text):
            pass
        else:
            raise ValidationError(
                message="Please enter a plugin name containing lowercase letters and digits",
                cursor_position=len(plugin_name.text),
            )


class semverValidator(Validator):
    def validate(self, version):
        import re
        if len(version.text) == 0:
            raise ValidationError(
                message="Please enter an valid semver-compliant version string",
                cursor_position=len(version.text),
            )
        else:
            regex = re.compile(r"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$")
            if (re.match(regex, version.text)):
                pass
            else:
                raise ValidationError(
                    message="Please enter an valid semver-compliant version string",
                    cursor_position=len(version.text),
                )


class emailValidator(Validator):
    def validate(self, email):
        import re
        if len(email.text) == 0:
            raise ValidationError(
                message="Please enter an email address",
                cursor_position=len(email.text),
            )
        else:
            regex = re.compile(r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
            if (re.match(regex, email.text)):
                pass
            else:
                raise ValidationError(
                    message="Please enter a valid email address format",
                    cursor_position=len(email.text),
                )


class urlValidator(Validator):
    def validate(self, repo):
        import re
        if len(repo.text) == 0:
            raise ValidationError(
                message="Please enter an url",
                cursor_position=len(repo.text),
            )
        else:
            regex = re.compile(
             r'^(?:http|ftp)s?://'                                                                   # http:// or https://
             r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'    # domain...
             r'localhost|'                                                                           # localhost...
             r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|'                                                  # ...or ipv4
             r'\[?[A-F0-9]*:[A-F0-9:]+\]?)'                                                          # ...or ipv6
             r'(?::\d+)?'                                                                            # optional port
             r'(?:/?|[/?]\S+)$', re.IGNORECASE)
        if re.match(regex, repo.text):
            pass
        else:
            raise ValidationError(
                message="Please enter a valid url format",
                cursor_position=len(repo.text),
            )


def construct_title():
    import os
    from scripts.utilities import iskbinstalled as iskbinstalled
    if iskbinstalled():
        from kb import __version__ as kb_version
    else:
        kb_version = '?.?.?'

    s = os.linesep
    title = '# -*- encoding: utf-8 -*-' + s
    title = title + '# kb v' + kb_version + s
    title = title + '# A knowledge base organizer' + s
    title = title + '# Copyright © 2020, gnc.' + s
    title = title + '# See /LICENSE for licensing information.' + s + s
    return title


def skeleton(args: Dict[str, str]):
    import os

    from pathlib import Path
    import uuid

    from lineinfile import AfterFirst, add_line_to_file, remove_lines_from_file
    from questionary import prompt

    from kb.printer.style import ALT_BGROUND, BOLD, UND, RESET

    from scripts.files import append_file as append_file, \
        create_structure as create_structure, \
        read_file as read_file, \
        read_toml_file as read_toml_file, \
        write_file as write_file, \
        write_toml_file as write_toml_file    
    from scripts.utilities import getnow as getnow, clear as clear


    plugin_name = 'coffee'
    copyright = 'Andrew Shapton'

    s = os.linesep
    base_dir = Path(os.path.dirname(__file__))
    target_py_file = str(Path(base_dir, 'plugins', plugin_name, 'plugin_main_tmp.py'))
    target_toml_file = str(Path(base_dir, 'config.tmp.toml'))
    target_custom_actions_file = str(Path(base_dir, 'custom_classes.py'))
    target_udt_file = str(Path(base_dir, 'custom_types.py'))

    
    write_file('', target_custom_actions_file, 'w')

    now = getnow()

    create_structure(base_dir, plugin_name)
    title = construct_title()
    title = title + '#' + s
    title = title + '# Main file for ' + plugin_name + ' plugin.' + s
    title = title + '#' + s
    title = title + '# :Copyright: © ' + now[0:4] + ', ' + copyright + s
    title = title + '# :License: GPLv3 (see /LICENSE).' + s
    title = title + '#' + s

    write_file(title + s, target_py_file, 'w')
    append_file(str(Path(base_dir, 'parts', 'plugin_main.part1')), target_py_file)
    

    os.chdir(Path.home())
    clear()
    print('Create the skeleton for a new plugin')
    print()
    print("Enter the following:")
    questions = [
                {'type': 'text', 'name': 'author', 'message': 'Your Name: ', 'qmark': '-',
                 # 'validate': lambda text: True if len(text) > 0 else "Your name"
                 },
                {'type': 'text', 'name': 'version', 'message': 'Version Number: ',
                 'instruction': 'MUST be in semver notation i.e. 0.0.1', 'qmark': '-',
                 # 'validate': semverValidator
                 },
                {'type': 'text', 'name': 'contact', 'message': 'Your Email: ', 'qmark': '-',
                 # 'validate': emailValidator
                 },
                {'type': 'text',  'name': 'plugin_name', 'message': 'The name of the new plugin: ', 'qmark': '-',
                 # 'validate': pluginNameValidator
                 },
                {'type': 'text', 'name': 'help', 'message': 'Description of the plugin: ',
                 'instruction': 'Text that will appear in the help for this plugin', 'qmark': '-',
                 # 'validate': lambda text: True if len(text) > 20 else "Please enter more than 20 characters"
                 },
                {'type': 'text', 'name': 'detail', 'message': 'Further detail for help : ', 'qmark': '-', },
                {'type': 'path', 'name': 'location', 'message': 'Location of the plugin code (Press <TAB>): ',
                 'qmark': '-', 'only_directories': True,
                 # 'validate': lambda a: True if a[1] != '.' else "You should select a directory which is not hidden"
                 },
                {'type': 'text', 'name': 'source', 'message': 'Remote repo. location: ',
                 'qmark': '-',
                 # 'validate': urlValidator,
                 },
    ]

    config = prompt(questions)
    write_file('', target_toml_file, 'w')

    now = getnow()

    title = construct_title()
    title = title + '#' + s
    title = title + '# Plugin extension plugin configuration file.' + s
    title = title + '#' + s
    title = title + '# :Copyright: © ' + now[0:4] + ', ' + config['plugin_name'] + s
    title = title + '# :License: GPLv3 (see /LICENSE).' + s
    title = title + '#' + s + s
    title = title + 'title = "Config file for ' + config['plugin_name'] + ' generated by kbplugin on ' + now[0:19] + '"'

    write_file(title + s + s, target_toml_file, 'a')

    toml_config = {
                    'config':
                    {
                     'name': config['plugin_name'],
                     'version': config['version'],
                     'guid': str(uuid.uuid4()),
                     'help': config['help'],
                     }
                }

    write_toml_file(toml_config, target_toml_file, 'a')

    write_file(s, target_toml_file, 'a')
    toml_metadata = {
                    'metadata':
                    {
                     'source': config['source'],
                     'author': config['author'],
                     'contact': config['contact'],
                     }
                }
    write_toml_file(toml_metadata, target_toml_file, 'a')

    command_name = {'type': 'text', 'name': 'command', 'message': 'Enter the command: ', 'qmark': '-', }
    another_command = {'type': 'confirm', 'name': 'another', 'message': 'Another command ?', 'qmark': '-', }
    another_argument = {'type': 'confirm', 'name': 'another', 'message': 'Another argument ?', 'qmark': '-', }

    parser_config = {
                    'parser':
                    {
                     'prefix': config['plugin_name'],
                     'entry': config['plugin_name'] + '_command',
                     'help': config['help'],
                     'detail': config['detail'],
                     }
                }

    write_file(s, target_toml_file, 'a')
    write_toml_file(parser_config, target_toml_file, 'a')
    clear()
    comm_title = BOLD + "First command for the " + config["plugin_name"] + ' plugin :' + RESET + s
    more_commands = {'another': True}
    while more_commands['another']:
        clear()
        comm_title = BOLD + "Next command for the " + config["plugin_name"] + ' plugin :' + RESET + s
        # Gather commaand information
        prsr_info = prompt(command_name)
        command_questions = {'type': 'text', 'name': 'help',
                             'message': 'Help for the ' + prsr_info["command"] + ' command: ', 'qmark': '-', }
        prsr_help = prompt(command_questions)
        commands_config = {
                            'command': prsr_info["command"],
                            'function': "do_" + prsr_info['command'],
                            'help': prsr_help['help'],
                           }
        # Write command information to configuration file and python file
        write_file(s + '[[commands]]' + s, target_toml_file, 'a')
        write_toml_file(commands_config, target_toml_file, 'a')
        write_file(s + "    _parser_" + prsr_info['command'] + " = globals()[PS].add_parser('" + prsr_info['command'] + "', help='" + prsr_help['help'] + "')", target_py_file, 'a')

        # Start to get arguments for command
        complete_args_info = []
        
        # Get arguments
        arg_title = BOLD + "First argument for the " + prsr_info["command"] + ' command :' + RESET + s
        more_args = {'another': True}
        while more_args['another']:
            clear()
            print(arg_title)
            arg_title = BOLD + "Next argument for the " + prsr_info["command"] + ' command :' + RESET + s
            this_arg_info = []
            arg_questions = [
                        {'type': 'text', 'name': 'argument', 'message': 'Option name(s): ', 'qmark': '-',},
                        {'type': 'select', 'name': 'action', 'message': 'Action to be taken: ', 'qmark': '-',
                            'choices': ['store', 'store_const', 'store_true', 'store_false', 'append', 'append_const',
                            'count', 'help', 'version', 'extend', 'Custom Action'],},
                        {'type': 'text', 'name': 'const', 'message': 'Constant to be stored: ', 'qmark': '   -',
                            "when": lambda x: x["action"] in ["store_const", "append_const"]},
                        {'type': 'text', 'name': 'customaction', 'message': 'Custom Action name: ', 'qmark': '   -',
                            "when": lambda x: x["action"] == "Custom Action",},
                        {'type': 'select', 'name': 'nargs', 'message': 'Number of arguments: ', 'qmark': '-',
                            'choices': ['?', '*', '+', '1', '2', '3', '4', '5', '6', '7', '8', '9', '>9'],},
                        {'type': 'text', 'name': 'default', 'message': 'Default value: ', 'qmark': '-',},
                        {'type': 'select', 'name': 'type', 'message': 'Type: ', 'qmark': '-',
                            'choices': ['str', 'int', 'float', 'ascii', 'ord', 'open', 'User Defined'],},
                        {'type': 'text', 'name': 'userdefinedtype', 'message': 'User Defined type: ', 'qmark': '   -',
                            "when": lambda x: x["type"] == "User Defined",},
                        {'type': 'text', 'name': 'choices', 'message': 'List of choices: ', 'qmark': '-',},
                        {'type': 'select', 'name': 'required', 'message': 'Required: ', 'qmark': '-',
                            'choices': ['Yes', 'No'],},
                        {'type': 'select', 'name': 'arghelp', 'message': 'Help ? ', 'qmark': '-',
                            'choices': ['Yes', 'No'],},
                        {'type': 'text', 'name': 'helpmessage', 'message': 'Help Message: ', 'qmark': '   -',
                            "when": lambda x: x["arghelp"] == "Yes",},
                        {'type': 'text', 'name': 'metavar', 'message': 'Metavar? ', 'qmark': '-',},
                        {'type': 'text', 'name': 'dest', 'message': 'Dest? ', 'qmark': '-',},
                        ]
            this_arg_info = prompt(arg_questions)
            write_file(s + "    _parser_" + prsr_info['command'] + ".add_argument(",target_py_file, 'a')
            write_file(s + "        " + this_arg_info['argument'] + ',' ,target_py_file, 'a')
            
            # Required
            if (this_arg_info['required']  == 'Yes'):
                write_file(s + "        " + "required=True,", target_py_file, 'a')
            else:
                write_file(s + "        " + "required=False,", target_py_file, 'a')

            # Action
            action = this_arg_info['action']
            
            if (action != 'Custom Action'):
                write_file(s + "        action='" + action + "',", target_py_file, 'a')

            if (action in ['store_const', 'append_const']):
                    write_file(s + "        const='" + this_arg_info['const'] + "',", target_py_file, 'a')
            
            if (action == 'version'):
                write_file(s + "        version='" + config['version'] + "',", target_py_file, 'a')
            
            if (action == 'Custom Action'):
                # Write/append custom action classes
                custom_actions = True
                write_file(s + "        action=" + this_arg_info['customaction'] + ",", target_py_file, 'a')
                write_file('class ' + this_arg_info['customaction']+'(argparse.Action):', target_custom_actions_file, 'a')
                write_file(s+ '    """Custom class for ' + this_arg_info['customaction'] + '"""', target_custom_actions_file, 'a')
                write_file (s+ '    def __call__(self, parser, namespace, values, option_string=None):' , target_custom_actions_file, 'a')
                write_file (s+ '    # Write your custom class code here' + s, target_custom_actions_file, 'a')
                write_file ('        pass' + s + s, target_custom_actions_file, 'a')

            # Help
            if (this_arg_info['arghelp'] == 'Yes'):
                write_file(s + "        " + "help='" + this_arg_info['helpmessage'] + "',", target_py_file, 'a')
 
            # nargs
            if (this_arg_info['nargs'] == '>9'):
                write_file(s + "        " + "nargs='XXXXXXXXXX',  # Ensure that the correct number of args is inserted here", target_py_file, 'a')
            else:
                if (this_arg_info['nargs'] != ''):
                    write_file(s + "        " + "nargs='" + this_arg_info['nargs'] + "',", target_py_file, 'a')

            # Default value
            if (this_arg_info['default']  != ''):
                write_file(s + "        " + "default='" + this_arg_info['default'] + "',", target_py_file, 'a')

            # Type
            if (this_arg_info['type'] != 'User Defined'):
                if (this_arg_info['type'] != ''):
                    write_file(s + "        " + "type='" + this_arg_info['type'] + "',", target_py_file, 'a')
            else:
                write_file(s + "        " + "type=" + this_arg_info['userdefinedtype'] + ",", target_py_file, 'a')
                write_file("def " + this_arg_info['userdefinedtype'] + "(value):" + s, target_udt_file, 'a')
                write_file("    # Definition for user-defined type for parser" + s, target_udt_file, 'a')
                write_file("    # Insert your code here" + s, target_udt_file, 'a')

                write_file("    Return None" + s + s, target_udt_file, 'a')
               


            # Choices
            if (this_arg_info['choices'] != ''):
                write_file(s + "        " + "choices='" + this_arg_info['choices'] + "',", target_py_file, 'a')

            # Metavar
            if (this_arg_info['metavar'] != ''):
                write_file(s + "        " + "metavar='" + this_arg_info['metavar'] + "',", target_py_file, 'a')

            # Dest
            if (this_arg_info['dest'] != ''):
                write_file(s + "        " + "dest='" + this_arg_info['dest'] + "',", target_py_file, 'a')

            write_file(s + "        )" + s, target_py_file, 'a')
            

            more_args = prompt(another_argument)
            clear()

            complete_args_info.append(this_arg_info)

        # complete_parser_info.append(complete_args_info)

        more_commands = prompt(another_command)
    
    append_file(str(Path(base_dir, 'parts', 'plugin_main.part2')), target_py_file)

    data = read_toml_file(target_toml_file[:-5])
    for command in data['commands']:

        write_file(s + 'def '+ command['function'] + '(args: Dict[str, str], config: Dict[str, str]):' + s, target_py_file, 'a')
        write_file('    # Insert code for the ' + command['command'] + ' function here. ' + s, target_py_file, 'a')
        write_file('    return None' + s, target_py_file, 'a')

    append_file(str(Path(base_dir, 'parts', 'plugin_main.part3')), target_py_file)

    # Inject custom action classes into the plugin_main.py file
    custom_action_classes = read_file(target_custom_actions_file)

    add_line_to_file(
        target_py_file,
        custom_action_classes,
        r"\b(CACLASSES)\b"
    )
    remove_lines_from_file(target_py_file, regexp=r"\b#  (CACLASSES)\b",)

    # Inject custom type definitions into the plugin_main.py file
    udts = read_file(target_udt_file)

    add_line_to_file(
        target_py_file,
        udts,
        r"\b(UDT)\b"
    )
    remove_lines_from_file(target_py_file, regexp=r"\b#  (UDT)\b",)
    return None


def stat(args: Dict[str, str]):
    from kb.printer.style import ALT_BGROUND, BOLD, UND, RESET
    from scripts.utilities import iskbinstalled as iskbinstalled
    from scripts.files import read_toml_file as read_toml_file
    PREFIX = ''
    SUFFIX = ''
    UPREFIX = ''

    if iskbinstalled():
        from kb import __version__ as kb_version
        data = read_toml_file(__file__)
        isconnected = data['status']['connected']
        if args['no_color']:
            PREFIX = BOLD
            SUFFIX = RESET
            UPREFIX = BOLD + UND

        if (isconnected):
            connectedtext = 'Connected'
        else:
            connectedtext = 'Disconnected'
    else:
        connectedtext = 'Not Installed'
        kb_version = connectedtext

    kb_plugin_version = read_toml_file(__file__)['info']['version']
    line1 = UPREFIX + "kb-plugin Status Information" + SUFFIX
    line2 = PREFIX + "kb-plugin Version  : " + kb_plugin_version + SUFFIX
    line3 = PREFIX + "kb Version         : " + kb_version + SUFFIX
    line4 = PREFIX + "Status             : " + connectedtext + SUFFIX

    print(line1)
    print(line2)
    print(line3)
    print(line4)


def disconnect(args: Dict[str, str]):
    from scripts.integration import disconnect as disconnect_from_kb
    disconnect_from_kb(args, __file__)
    return None


def connect(args: Dict[str, str]):
    from scripts.integration import connect as connect_to_kb
    connect_to_kb(args ,__file__)
    return None


def parse_args(args: Sequence[str]) -> argparse.Namespace:
    """
    This function parses the arguments which have been passed from the command
    line, these can be easily retrieved for example by using "sys.argv[1:]".
    It returns an argparse Namespace object.

    Arguments:
    args -- the list of arguments passed from the command line as the sys.argv
            format

    Returns:
    An argparse Namespace object with the provided arguments, which
    can be used in a simpler format.
    """
    from scripts.files import read_toml_file as read_toml_file

    parser = argparse.ArgumentParser(prog='kbplugin',
                                     description='A plugin manager for kb')
    parser.add_argument(
        "--version",
        action="version",
        version="%(prog)s {}".format(read_toml_file(__file__)['info']['version']))

    # Main Commands

    subparsers = parser.add_subparsers(help='commands', dest="command")
    subparsers.required = True

    _connect_parser = subparsers.add_parser(
        'connect', help='Connect kb-plugin to the kb instance')

    _disconnect_parser = subparsers.add_parser(
        'disconnect', help='Disconnect kb-plugin to the kb instance')

    _skeleton_parser = subparsers.add_parser(
        'skeleton', help='Create a skeleton plugin to modify')
    _skeleton_parser.add_argument(
        "name",
        help="Name of plugin to create",
        action='store_false',
        )

    _status_parser = subparsers.add_parser(
        'status', help='Show information about kb-plugin')
    _status_parser.add_argument(
        "-n", "--no-color",
        help="Enable no-color mode",
        action='store_false',
        dest='no_color',
        default=True)

    help_parser = subparsers.add_parser(
        'help', help='Show help of a particular command')
    help_parser.add_argument(
        'cmd',
        help='Name of command to get help for',
        nargs='?'
    )

    if len(args) == 0:
        parser.print_help(sys.stderr)
        sys.exit(1)

    parsed_args = parser.parse_args()
    if parsed_args.command == 'help':
        if not parsed_args.cmd:
            parser.print_help(sys.stderr)
        else:
            try:
                subparsers.choices[parsed_args.cmd].print_help()
            except KeyError:
                print(f'Unknown command name `{parsed_args.cmd}`')
                print(
                    f"Valid commands are: {', '.join(subparsers.choices.keys())}"
                )
        sys.exit(1)
    return parsed_args


def dispatch(function, *args, **kwargs):
    """
    Dispatch command line action to proper
    kb function
    """
    return CMDS[function](*args, **kwargs)


"""Main routine of kbplugin."""

CMDS = {
    'connect': connect,
    'disconnect': disconnect,
    'skeleton': skeleton,
    'status': stat,
}

args = parse_args(sys.argv[1:])
cmd = args.command
cmd_params = vars(args)
dispatch(cmd, cmd_params)
